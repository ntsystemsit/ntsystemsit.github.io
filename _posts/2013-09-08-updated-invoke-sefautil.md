---
layout: post
title: "Updated: Invoke-SEFAUtil"
date: 2013-09-08 21:52:08 +0200
comments: true
published: true
categories: ["blog", "archives"]
excerpt_separator: <!-- more -->
tags: ["en", "PowerShell", "Lync"]
alias: ["/post/Updated-Invoke-SEFAUtil.aspx", "/post/updated-invoke-sefautil.aspx"]
---
<!-- more -->
{% include imported_disclaimer.html %}
<p>Some weeks ago, I’ve written about my PowerShell wrapper function for SEFAUtil.exe, the original post can be found here: <a title="/post/Invoke-SEFAUtil-a-PowerShell-wrapper-function.aspx" href="/post/Invoke-SEFAUtil-a-PowerShell-wrapper-function.aspx">/post/Invoke-SEFAUtil-a-PowerShell-wrapper-function.aspx</a></p>  <h1>GUI</h1>  <p>First of all, in case you haven’t seen it yet, MVP Johan Veldhuis created an AWESOME GUI wrapper. Check it out: <a title="http://johanveldhuis.nl/en/sefautil-gui/" href="http://johanveldhuis.nl/en/sefautil-gui/">http://johanveldhuis.nl/en/sefautil-gui/</a></p>  <p>If you still want to run it via PowerShell, keep on reading ;)</p>  <h1></h1>  <h1>Updated Script</h1>  <p>After playing around with my script I figured it would be cool if it would return more “PowerShell like” objects instead of the plain text returned by sefautil.exe. I also wanted it to take pipeline input and updated the related links to point to a help page instead of the blog article. </p>  <h2></h2>  <h2>Turning a bunch of strings into a PowerShell object</h2>  <p>Looking at the text output of the tool, we can see it has a format of “description : value”. </p>  <p>Sample output:</p>  <blockquote>   <p>User Aor: sip:ttorggler@uclab.eu      <br />Display Name: Thomas Torggler       <br />UM Enabled: True       <br />Simulring enabled: False       <br />User Ring time: 00:00:30       <br />Call Forward No Answer to: voicemail</p> </blockquote>  <p>As they have the same structure, this does immediately bring PowerShell dictionaries (hashtables) to mind. I simply used the –split method to split the strings at “: “ (colon space) and saved the result to a new array.</p>  <blockquote>   <p>$SEFAResultSplit = $SEFAResult -split ': '</p> </blockquote>  <p>This worked as expected, so I went ahead and created my custom object like this:</p>  <blockquote>   <p>$data =&#160; @{$SEFAResultSplit[0] = $SEFAResultSplit[1];      <br />$SEFAResultSplit[2] = $SEFAResultSplit[3];       <br />}</p> </blockquote>  <p>After testing it in the lab, I realized, even though this worked, it was less then ideal. Sefautil returns a dynamic amount of strings depending on which features are configured for the given user. So while it was reasonably sure that ”$SEFAResultSplit[0]” would always be “User Aor”, I would have no way of knowing the value of the next strings. And, more importantly, I would not know how many strings to expect, a more dynamic approach was needed.</p>  <p>This is what I came up with after some serious head scratching:</p>  <blockquote>   <p>for ($i = 0; $i -lt $SEFAResultSplit.Count; $i++) {      <br />&#160;&#160;&#160; if ([bool]!($i%2)) {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $j = $i + 1       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $outData += @{$SEFAResultSplit[$i] = $SEFAResultSplit[$j]}       <br />&#160;&#160;&#160; }       <br />}</p> </blockquote>  <p>And here is what it does: The array that contains the split strings would always contain the “description” at an even number while the actual values would be found at odd numbers. So, the script loops through the array, and for each even number it creates a new “Key : Value” pair that is saved to a hash table. </p>  <p>Whatever object in the array is at the even index number would be used as key, and that even number +1 would be used as value. Sweet.</p>  <h2></h2>  <h2>Why?</h2>  <p>Well, first of all, because it’s cool ;)</p>  <p>Then, think about this:</p>  <blockquote>   <p>Get-CsUser –OU &quot;OU=users,OU=Italy,DC=tomt,DC=local&quot; | .\Invoke-SEFAUtil.ps1 –Server ly15.tomt.local | Where-Object {‘Simulring enabled’ –eq $true}</p> </blockquote>  <p>First the Get-CsUser cmdlet is used to get all users within a specified organizational unit, the user objects are then piped into my wrapper script and the output can be filtered just like any other PowerShell output. Of course it could also be converted to html or exported to csv, the point is returning objects instead of text.</p>  <p>Sure enough, we can now also take advantage of pipeline input processing to set call forwarding settings for multiple users:</p>  <blockquote>   <p>Get-CsUser -OU &quot;OU=users,OU=Italy,DC=tomt,DC=local&quot; | .\Invoke-SEFAUtil.ps1 -Server ly15.tomt.local -Verbose -AddDelegate <a href="mailto:user1@tomt.it">user1@tomt.it</a></p> </blockquote>  <p>Again, we use Get-CsUser to get some Lync Users and pipe them to the script, which adds <a href="mailto:user1@tomt.it">user1@tomt.it</a> as a delegate to the every one of the users. </p>  <h1>Download</h1>  <p>I’ve updated the script on my Sky Drive, find a link at the new <a href="/page/PS-Invoke-SEFAUtilps1.aspx" target="_blank">help page</a>.</p>  <p>Cheers,    <br />tom</p>
